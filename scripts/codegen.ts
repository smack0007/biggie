#!/usr/bin/env -S deno run -RW --allow-run
import { join, resolve } from "node:path";
import { EOL } from "node:os";
import { readFile, writeFile } from "node:fs/promises";
import { argv, exit } from "node:process";
import { OutputWriter } from "../src/outputWriter.ts";
import { int } from "../src/shims.ts";
import { firstLetterToLower } from "../src/utils.ts";
import { formatFile } from "./utils.ts";

const ROOT_PATH = resolve(import.meta.dirname!, "..");

main(argv.slice(2)).then(exit);

async function main(_argv: string[]): Promise<int> {
  await writeAstForEachChild();

  return 0;
}

async function writeAstForEachChild(): Promise<void> {
  const outputWriter = new OutputWriter();

  outputWriter.appendLine(`
//! This file is autogenerated from ast.ts.
import * as ast from "./ast.ts";
import { bool, isError, isSuccess, Result, success } from "../shims.ts";

export type WalkAstCallback<Error = unknown> = (node: ast.SyntaxNode, parent?: ast.SyntaxNode) => Result<bool, Error>;

export function walkAst<Error = unknown>(node: ast.SyntaxNode, callback: WalkAstCallback<Error>): Result<void, Error> {
  return walkAstParent<Error>(node, callback);
}

function walkAstParent<Error = unknown>(
  node: ast.SyntaxNode,
  callback: WalkAstCallback<Error>,
  parent?: ast.SyntaxNode,
): Result<void, Error> {
  const callbackResult = callback(node, parent);

  // NOTE: The return value of callback indicates if we should keep descending further into the tree.
  if (isSuccess(callbackResult) && callbackResult.value) {
    const childrenResult = walkAstChildren<Error>(node, callback);

    if (isError(childrenResult)) {
      return childrenResult;
    }
  }

  return success();
}

export function walkAstArray<Error = unknown>(nodes: ast.SyntaxNode[], callback: WalkAstCallback<Error>): Result<void, Error> {
  return walkAstArrayParent<Error>(nodes, callback);
}

function walkAstArrayParent<Error = unknown>(
  nodes: ast.SyntaxNode[],
  callback: WalkAstCallback<Error>,
  parent?: ast.SyntaxNode,
): Result<void, Error> {
  for (const node of nodes) {
    const result = walkAstParent<Error>(node, callback, parent);

    if (isError(result)) {
      return result;
    }
  }

  return success();
}

export type WalkAstChildrenCallback<Error = unknown> = (
  node: ast.SyntaxNode,
  parent: ast.SyntaxNode,
) => Result<bool, Error>;

export function walkAstChildren<Error = unknown>(
  node: ast.SyntaxNode,
  callback: WalkAstChildrenCallback<Error>,
): Result<void, Error> {
  let result: Result<void, Error>;
  switch (node.kind) {
`);

  const astContents = await readFile(join(ROOT_PATH, "src", "frontend", "ast.ts"), "utf-8");

  outputWriter.indent();
  outputWriter.indent();
  let interfaceName: string | null = null;
  let caseBlockIsOutput = false;
  for (const line of astContents.split(EOL).map((x) => x.trim())) {
    if (interfaceName == null && line.startsWith("export interface ") && !line.endsWith("{}")) {
      const parts = line.split(" ");
      interfaceName = parts[2];

      if (["SyntaxNode", "BlockScope", "Declaration"].includes(interfaceName)) {
        interfaceName = null;
        continue;
      }
    }

    if (interfaceName != null) {
      if (line.startsWith("readonly ")) {
        const parts = line.split(" ");
        let propertyName = parts[1].replaceAll(":", "");

        if (["kind", "exports?", "fileName", "isExported", "operator", "symbol?", "value"].includes(propertyName)) {
          continue;
        }

        const type = parts[2].substring(0, parts[2].length - 1);

        if (type == "string") {
          continue;
        }

        if (!caseBlockIsOutput) {
          outputWriter.appendLine(`case ast.SyntaxKind.${interfaceName}: {`);
          outputWriter.indent();
          outputWriter.appendLine(`const ${firstLetterToLower(interfaceName)} = <ast.${interfaceName}>node;`);
          caseBlockIsOutput = true;
        }

        let isOptional = false;
        if (propertyName.endsWith("?")) {
          propertyName = propertyName.replaceAll("?", "");
          outputWriter.appendLine(`if (${firstLetterToLower(interfaceName)}.${propertyName}) {`);
          outputWriter.indent();
          isOptional = true;
        }

        let walkFunc = "walkAstParent";
        if (type.endsWith("[]")) {
          walkFunc = "walkAstArrayParent";
        }

        outputWriter.appendLine(
          `result = ${walkFunc}<Error>(${
            firstLetterToLower(interfaceName)
          }.${propertyName}, <WalkAstCallback<Error>>callback, ${firstLetterToLower(interfaceName)});`,
        );

        outputWriter.appendLine("if (isError(result)) return result;");

        if (isOptional) {
          outputWriter.append("}");
          outputWriter.unindent();
        }
      } else if (line.startsWith("}")) {
        if (caseBlockIsOutput) {
          outputWriter.appendLine("} break;");
          outputWriter.unindent();
        }
        interfaceName = null;
        caseBlockIsOutput = false;
      }
    }
  }
  outputWriter.unindent();
  outputWriter.appendLine("}");
  outputWriter.appendLine("return success();");

  outputWriter.unindent();
  outputWriter.appendLine("}");

  const outputPath = join(ROOT_PATH, "src", "frontend", "walkAst.ts");
  await writeFile(outputPath, outputWriter.toString());
  await formatFile(outputPath);
}
