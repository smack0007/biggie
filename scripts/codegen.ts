#!/usr/bin/env -S deno run -RW --allow-run
import { join, resolve } from "node:path";
import { EOL } from "node:os";
import { readFile, writeFile } from "node:fs/promises";
import { argv, exit } from "node:process";
import { OutputWriter } from "../src/outputWriter.ts";
import { int } from "../src/shims.ts";
import { firstLetterToLower } from "../src/utils.ts";
import { formatFile } from "./utils.ts";

const ROOT_PATH = resolve(import.meta.dirname!, "..");

main(argv.slice(2)).then(exit);

async function main(_argv: string[]): Promise<int> {
  await writeAstForEachChild();

  return 0;
}

async function writeAstForEachChild(): Promise<void> {
  const outputWriter = new OutputWriter();
  outputWriter.appendLine("//! This file is autogenerated from ast.ts.");

  outputWriter.appendLine(`import * as ast from "./ast.ts"`);
  outputWriter.appendLine(`import { bool } from "../shims.ts"`);

  outputWriter.appendLine();
  outputWriter.appendLine("export type WalkAstCallback = (node: ast.SyntaxNode, parent?: ast.SyntaxNode) => bool;");

  outputWriter.appendLine(
    `
export function walkAst(node: ast.SyntaxNode, callback: WalkAstCallback): void {
  walkAstParent(node, callback);
}

function walkAstParent(node: ast.SyntaxNode, callback: WalkAstCallback, parent?: ast.SyntaxNode): void {
  // NOTE: The return value of callback indicates if we should keep descending further into the tree.
  if (callback(node, parent)) {
    walkAstChildren(node, callback);
  }
}

export function walkAstArray(nodes: ast.SyntaxNode[], callback: WalkAstCallback): void {
  return walkAstArrayParent(nodes, callback);
}

function walkAstArrayParent(nodes: ast.SyntaxNode[], callback: WalkAstCallback, parent?: ast.SyntaxNode): void {
  for (const node of nodes) {
    walkAstParent(node, callback, parent);
  }
}`,
  );
  outputWriter.appendLine();

  const astContents = await readFile(join(ROOT_PATH, "src", "frontend", "ast.ts"), "utf-8");

  outputWriter.appendLine(
    `export function walkAstChildren(node: ast.SyntaxNode, callback: (node: ast.SyntaxNode, parent: ast.SyntaxNode) => bool): void {`,
  );
  outputWriter.indent();
  outputWriter.appendLine("switch(node.kind) {");

  outputWriter.indent();
  let interfaceName: string | null = null;
  let caseBlockIsOutput = false;
  for (const line of astContents.split(EOL).map((x) => x.trim())) {
    if (interfaceName == null && line.startsWith("export interface ") && !line.endsWith("{}")) {
      const parts = line.split(" ");
      interfaceName = parts[2];

      if (["SyntaxNode", "BlockScope", "Declaration"].includes(interfaceName)) {
        interfaceName = null;
        continue;
      }
    }

    if (interfaceName != null) {
      if (line.startsWith("readonly ")) {
        const parts = line.split(" ");
        let propertyName = parts[1].replaceAll(":", "");

        if (["kind", "exports?", "fileName", "isExported", "operator", "symbol?", "value"].includes(propertyName)) {
          continue;
        }

        const type = parts[2].substring(0, parts[2].length - 1);

        if (type == "string") {
          continue;
        }

        if (!caseBlockIsOutput) {
          outputWriter.appendLine(`case ast.SyntaxKind.${interfaceName}: {`);
          outputWriter.indent();
          outputWriter.appendLine(`const ${firstLetterToLower(interfaceName)} = <ast.${interfaceName}>node;`);
          caseBlockIsOutput = true;
        }

        if (propertyName.endsWith("?")) {
          propertyName = propertyName.replaceAll("?", "");
          outputWriter.append(`if (${firstLetterToLower(interfaceName)}.${propertyName}) `);
        }

        let walkFunc = "walkAstParent";
        if (type.endsWith("[]")) {
          walkFunc = "walkAstArrayParent";
        }

        outputWriter.appendLine(
          `${walkFunc}(${firstLetterToLower(interfaceName)}.${propertyName}, <WalkAstCallback>callback, ${
            firstLetterToLower(interfaceName)
          });`,
        );
      } else if (line.startsWith("}")) {
        if (caseBlockIsOutput) {
          outputWriter.appendLine("} break;");
          outputWriter.unindent();
        }
        interfaceName = null;
        caseBlockIsOutput = false;
      }
    }
  }
  outputWriter.unindent();
  outputWriter.appendLine("}");

  outputWriter.unindent();
  outputWriter.appendLine("}");

  const outputPath = join(ROOT_PATH, "src", "frontend", "walkAst.ts");
  await writeFile(outputPath, outputWriter.toString());
  await formatFile(outputPath);
}
