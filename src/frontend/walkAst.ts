//! This file is autogenerated from ast.ts.
import * as ast from "./ast.ts";
import { bool } from "../shims.ts";

export type WalkAstCallback = (node: ast.SyntaxNode, parent?: ast.SyntaxNode) => bool;

export function walkAst(node: ast.SyntaxNode, callback: WalkAstCallback): void {
  walkAstParent(node, callback);
}

function walkAstParent(node: ast.SyntaxNode, callback: WalkAstCallback, parent?: ast.SyntaxNode): void {
  // NOTE: The return value of callback indicates if we should keep descending further into the tree.
  if (callback(node, parent)) {
    walkAstChildren(node, callback);
  }
}

export function walkAstArray(nodes: ast.SyntaxNode[], callback: WalkAstCallback): void {
  return walkAstArrayParent(nodes, callback);
}

function walkAstArrayParent(nodes: ast.SyntaxNode[], callback: WalkAstCallback, parent?: ast.SyntaxNode): void {
  for (const node of nodes) {
    walkAstParent(node, callback, parent);
  }
}

export function walkAstChildren(
  node: ast.SyntaxNode,
  callback: (node: ast.SyntaxNode, parent: ast.SyntaxNode) => bool,
): void {
  switch (node.kind) {
    case ast.SyntaxKind.SourceFile:
      {
        const sourceFile = <ast.SourceFile> node;
        walkAstArrayParent(sourceFile.statements, <WalkAstCallback> callback, sourceFile);
      }
      break;
    case ast.SyntaxKind.ImportDeclaration:
      {
        const importDeclaration = <ast.ImportDeclaration> node;
        walkAstParent(importDeclaration.module, <WalkAstCallback> callback, importDeclaration);
        if (importDeclaration.alias) {
          walkAstParent(importDeclaration.alias, <WalkAstCallback> callback, importDeclaration);
        }
      }
      break;
    case ast.SyntaxKind.VariableDeclaration:
      {
        const variableDeclaration = <ast.VariableDeclaration> node;
        walkAstParent(variableDeclaration.name, <WalkAstCallback> callback, variableDeclaration);
        walkAstParent(variableDeclaration.type, <WalkAstCallback> callback, variableDeclaration);
        if (variableDeclaration.initializer) {
          walkAstParent(variableDeclaration.initializer, <WalkAstCallback> callback, variableDeclaration);
        }
      }
      break;
    case ast.SyntaxKind.EnumDeclaration:
      {
        const enumDeclaration = <ast.EnumDeclaration> node;
        walkAstParent(enumDeclaration.name, <WalkAstCallback> callback, enumDeclaration);
        walkAstArrayParent(enumDeclaration.members, <WalkAstCallback> callback, enumDeclaration);
      }
      break;
    case ast.SyntaxKind.EnumMember:
      {
        const enumMember = <ast.EnumMember> node;
        walkAstParent(enumMember.name, <WalkAstCallback> callback, enumMember);
        if (enumMember.initializer) walkAstParent(enumMember.initializer, <WalkAstCallback> callback, enumMember);
      }
      break;
    case ast.SyntaxKind.FunctionDeclaration:
      {
        const functionDeclaration = <ast.FunctionDeclaration> node;
        walkAstParent(functionDeclaration.name, <WalkAstCallback> callback, functionDeclaration);
        walkAstArrayParent(functionDeclaration.arguments, <WalkAstCallback> callback, functionDeclaration);
        walkAstParent(functionDeclaration.returnType, <WalkAstCallback> callback, functionDeclaration);
        walkAstParent(functionDeclaration.body, <WalkAstCallback> callback, functionDeclaration);
      }
      break;
    case ast.SyntaxKind.FunctionArgument:
      {
        const functionArgument = <ast.FunctionArgument> node;
        walkAstParent(functionArgument.name, <WalkAstCallback> callback, functionArgument);
        walkAstParent(functionArgument.type, <WalkAstCallback> callback, functionArgument);
      }
      break;
    case ast.SyntaxKind.StructDeclaration:
      {
        const structDeclaration = <ast.StructDeclaration> node;
        walkAstParent(structDeclaration.name, <WalkAstCallback> callback, structDeclaration);
        walkAstArrayParent(structDeclaration.members, <WalkAstCallback> callback, structDeclaration);
      }
      break;
    case ast.SyntaxKind.StructMember:
      {
        const structMember = <ast.StructMember> node;
        walkAstParent(structMember.name, <WalkAstCallback> callback, structMember);
        walkAstParent(structMember.type, <WalkAstCallback> callback, structMember);
      }
      break;
    case ast.SyntaxKind.ExpressionStatement:
      {
        const expressionStatement = <ast.ExpressionStatement> node;
        walkAstParent(expressionStatement.expression, <WalkAstCallback> callback, expressionStatement);
      }
      break;
    case ast.SyntaxKind.DeferStatement:
      {
        const deferStatement = <ast.DeferStatement> node;
        walkAstParent(deferStatement.body, <WalkAstCallback> callback, deferStatement);
      }
      break;
    case ast.SyntaxKind.IfStatement:
      {
        const ifStatement = <ast.IfStatement> node;
        walkAstParent(ifStatement.condition, <WalkAstCallback> callback, ifStatement);
        walkAstParent(ifStatement.then, <WalkAstCallback> callback, ifStatement);
        if (ifStatement.else) walkAstParent(ifStatement.else, <WalkAstCallback> callback, ifStatement);
      }
      break;
    case ast.SyntaxKind.WhileStatement:
      {
        const whileStatement = <ast.WhileStatement> node;
        walkAstParent(whileStatement.condition, <WalkAstCallback> callback, whileStatement);
        walkAstParent(whileStatement.body, <WalkAstCallback> callback, whileStatement);
      }
      break;
    case ast.SyntaxKind.ReturnStatement:
      {
        const returnStatement = <ast.ReturnStatement> node;
        walkAstParent(returnStatement.expression, <WalkAstCallback> callback, returnStatement);
      }
      break;
    case ast.SyntaxKind.StatementBlock:
      {
        const statementBlock = <ast.StatementBlock> node;
        walkAstArrayParent(statementBlock.statements, <WalkAstCallback> callback, statementBlock);
      }
      break;
    case ast.SyntaxKind.LogicalExpression:
      {
        const logicalExpression = <ast.LogicalExpression> node;
        walkAstParent(logicalExpression.lhs, <WalkAstCallback> callback, logicalExpression);
        walkAstParent(logicalExpression.rhs, <WalkAstCallback> callback, logicalExpression);
      }
      break;
    case ast.SyntaxKind.AssignmentExpression:
      {
        const assignmentExpression = <ast.AssignmentExpression> node;
        walkAstParent(assignmentExpression.name, <WalkAstCallback> callback, assignmentExpression);
      }
      break;
    case ast.SyntaxKind.EqualityExpression:
      {
        const equalityExpression = <ast.EqualityExpression> node;
        walkAstParent(equalityExpression.lhs, <WalkAstCallback> callback, equalityExpression);
        walkAstParent(equalityExpression.rhs, <WalkAstCallback> callback, equalityExpression);
      }
      break;
    case ast.SyntaxKind.ComparisonExpression:
      {
        const comparisonExpression = <ast.ComparisonExpression> node;
        walkAstParent(comparisonExpression.lhs, <WalkAstCallback> callback, comparisonExpression);
        walkAstParent(comparisonExpression.rhs, <WalkAstCallback> callback, comparisonExpression);
      }
      break;
    case ast.SyntaxKind.AdditiveExpression:
      {
        const additiveExpression = <ast.AdditiveExpression> node;
        walkAstParent(additiveExpression.lhs, <WalkAstCallback> callback, additiveExpression);
        walkAstParent(additiveExpression.rhs, <WalkAstCallback> callback, additiveExpression);
      }
      break;
    case ast.SyntaxKind.MultiplicativeExpression:
      {
        const multiplicativeExpression = <ast.MultiplicativeExpression> node;
        walkAstParent(multiplicativeExpression.lhs, <WalkAstCallback> callback, multiplicativeExpression);
        walkAstParent(multiplicativeExpression.rhs, <WalkAstCallback> callback, multiplicativeExpression);
      }
      break;
    case ast.SyntaxKind.UnaryExpression:
      {
        const unaryExpression = <ast.UnaryExpression> node;
        walkAstParent(unaryExpression.expression, <WalkAstCallback> callback, unaryExpression);
      }
      break;
    case ast.SyntaxKind.ParenthesizedExpression:
      {
        const parenthesizedExpression = <ast.ParenthesizedExpression> node;
        walkAstParent(parenthesizedExpression.expression, <WalkAstCallback> callback, parenthesizedExpression);
      }
      break;
    case ast.SyntaxKind.CallExpression:
      {
        const callExpression = <ast.CallExpression> node;
        walkAstParent(callExpression.expression, <WalkAstCallback> callback, callExpression);
        walkAstArrayParent(callExpression.arguments, <WalkAstCallback> callback, callExpression);
      }
      break;
    case ast.SyntaxKind.ElementAccessExpression:
      {
        const elementAccessExpression = <ast.ElementAccessExpression> node;
        walkAstParent(elementAccessExpression.expression, <WalkAstCallback> callback, elementAccessExpression);
        walkAstParent(elementAccessExpression.argumentExpression, <WalkAstCallback> callback, elementAccessExpression);
      }
      break;
    case ast.SyntaxKind.PropertyAccessExpression:
      {
        const propertyAccessExpression = <ast.PropertyAccessExpression> node;
        walkAstParent(propertyAccessExpression.expression, <WalkAstCallback> callback, propertyAccessExpression);
        walkAstParent(propertyAccessExpression.name, <WalkAstCallback> callback, propertyAccessExpression);
      }
      break;
    case ast.SyntaxKind.ArrayType:
      {
        const arrayType = <ast.ArrayType> node;
        walkAstParent(arrayType.elementType, <WalkAstCallback> callback, arrayType);
      }
      break;
    case ast.SyntaxKind.PointerType:
      {
        const pointerType = <ast.PointerType> node;
        walkAstParent(pointerType.elementType, <WalkAstCallback> callback, pointerType);
      }
      break;
    case ast.SyntaxKind.TypeReference:
      {
        const typeReference = <ast.TypeReference> node;
        walkAstParent(typeReference.typeName, <WalkAstCallback> callback, typeReference);
      }
      break;
    case ast.SyntaxKind.QualifiedName:
      {
        const qualifiedName = <ast.QualifiedName> node;
        walkAstParent(qualifiedName.left, <WalkAstCallback> callback, qualifiedName);
        walkAstParent(qualifiedName.right, <WalkAstCallback> callback, qualifiedName);
      }
      break;
    case ast.SyntaxKind.ArrayLiteral:
      {
        const arrayLiteral = <ast.ArrayLiteral> node;
        walkAstArrayParent(arrayLiteral.elements, <WalkAstCallback> callback, arrayLiteral);
      }
      break;
    case ast.SyntaxKind.StructLiteral:
      {
        const structLiteral = <ast.StructLiteral> node;
        walkAstArrayParent(structLiteral.elements, <WalkAstCallback> callback, structLiteral);
      }
      break;
    case ast.SyntaxKind.StructLiteralElement:
      {
        const structLiteralElement = <ast.StructLiteralElement> node;
        if (structLiteralElement.name) {
          walkAstParent(structLiteralElement.name, <WalkAstCallback> callback, structLiteralElement);
        }
        walkAstParent(structLiteralElement.expression, <WalkAstCallback> callback, structLiteralElement);
      }
      break;
  }
}
