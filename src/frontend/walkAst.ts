//! This file is autogenerated from ast.ts.
import * as ast from "./ast.ts";
import { bool, isError, isSuccess, Result, success } from "../shims.ts";

export type WalkAstCallback<Error = unknown> = (node: ast.SyntaxNode, parent?: ast.SyntaxNode) => Result<bool, Error>;

export function walkAst<Error = unknown>(node: ast.SyntaxNode, callback: WalkAstCallback<Error>): Result<void, Error> {
  return walkAstParent<Error>(node, callback);
}

function walkAstParent<Error = unknown>(
  node: ast.SyntaxNode,
  callback: WalkAstCallback<Error>,
  parent?: ast.SyntaxNode,
): Result<void, Error> {
  const callbackResult = callback(node, parent);

  if (isError(callbackResult)) {
    return callbackResult;
  }

  // NOTE: The return value of callback indicates if we should keep descending further into the tree.
  if (isSuccess(callbackResult) && callbackResult.value) {
    const childrenResult = walkAstChildren<Error>(node, callback);

    if (isError(childrenResult)) {
      return childrenResult;
    }
  }

  return success();
}

export function walkAstArray<Error = unknown>(
  nodes: ast.SyntaxNode[],
  callback: WalkAstCallback<Error>,
): Result<void, Error> {
  return walkAstArrayParent<Error>(nodes, callback);
}

function walkAstArrayParent<Error = unknown>(
  nodes: ast.SyntaxNode[],
  callback: WalkAstCallback<Error>,
  parent?: ast.SyntaxNode,
): Result<void, Error> {
  for (const node of nodes) {
    const result = walkAstParent<Error>(node, callback, parent);

    if (isError(result)) {
      return result;
    }
  }

  return success();
}

export type WalkAstChildrenCallback<Error = unknown> = (
  node: ast.SyntaxNode,
  parent: ast.SyntaxNode,
) => Result<bool, Error>;

export function walkAstChildren<Error = unknown>(
  node: ast.SyntaxNode,
  callback: WalkAstChildrenCallback<Error>,
): Result<void, Error> {
  let result: Result<void, Error>;
  switch (node.kind) {
    case ast.SyntaxKind.SourceFile:
      {
        const sourceFile = <ast.SourceFile> node;
        result = walkAstArrayParent<Error>(sourceFile.statements, <WalkAstCallback<Error>> callback, sourceFile);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.ImportDeclaration:
      {
        const importDeclaration = <ast.ImportDeclaration> node;
        if (importDeclaration.alias) {
          result = walkAstParent<Error>(importDeclaration.alias, <WalkAstCallback<Error>> callback, importDeclaration);
          if (isError(result)) return result;
        }
        result = walkAstParent<Error>(importDeclaration.module, <WalkAstCallback<Error>> callback, importDeclaration);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.VariableDeclaration:
      {
        const variableDeclaration = <ast.VariableDeclaration> node;
        result = walkAstParent<Error>(variableDeclaration.name, <WalkAstCallback<Error>> callback, variableDeclaration);
        if (isError(result)) return result;
        result = walkAstParent<Error>(variableDeclaration.type, <WalkAstCallback<Error>> callback, variableDeclaration);
        if (isError(result)) return result;
        if (variableDeclaration.initializer) {
          result = walkAstParent<Error>(
            variableDeclaration.initializer,
            <WalkAstCallback<Error>> callback,
            variableDeclaration,
          );
          if (isError(result)) return result;
        }
      }
      break;
    case ast.SyntaxKind.EnumDeclaration:
      {
        const enumDeclaration = <ast.EnumDeclaration> node;
        result = walkAstParent<Error>(enumDeclaration.name, <WalkAstCallback<Error>> callback, enumDeclaration);
        if (isError(result)) return result;
        result = walkAstArrayParent<Error>(enumDeclaration.members, <WalkAstCallback<Error>> callback, enumDeclaration);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.EnumMember:
      {
        const enumMember = <ast.EnumMember> node;
        result = walkAstParent<Error>(enumMember.name, <WalkAstCallback<Error>> callback, enumMember);
        if (isError(result)) return result;
        if (enumMember.initializer) {
          result = walkAstParent<Error>(enumMember.initializer, <WalkAstCallback<Error>> callback, enumMember);
          if (isError(result)) return result;
        }
      }
      break;
    case ast.SyntaxKind.FunctionDeclaration:
      {
        const functionDeclaration = <ast.FunctionDeclaration> node;
        result = walkAstParent<Error>(functionDeclaration.name, <WalkAstCallback<Error>> callback, functionDeclaration);
        if (isError(result)) return result;
        result = walkAstArrayParent<Error>(
          functionDeclaration.arguments,
          <WalkAstCallback<Error>> callback,
          functionDeclaration,
        );
        if (isError(result)) return result;
        result = walkAstParent<Error>(
          functionDeclaration.returnType,
          <WalkAstCallback<Error>> callback,
          functionDeclaration,
        );
        if (isError(result)) return result;
        result = walkAstParent<Error>(functionDeclaration.body, <WalkAstCallback<Error>> callback, functionDeclaration);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.StructDeclaration:
      {
        const structDeclaration = <ast.StructDeclaration> node;
        result = walkAstParent<Error>(structDeclaration.name, <WalkAstCallback<Error>> callback, structDeclaration);
        if (isError(result)) return result;
        result = walkAstArrayParent<Error>(
          structDeclaration.members,
          <WalkAstCallback<Error>> callback,
          structDeclaration,
        );
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.StructMember:
      {
        const structMember = <ast.StructMember> node;
        result = walkAstParent<Error>(structMember.name, <WalkAstCallback<Error>> callback, structMember);
        if (isError(result)) return result;
        result = walkAstParent<Error>(structMember.type, <WalkAstCallback<Error>> callback, structMember);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.ExpressionStatement:
      {
        const expressionStatement = <ast.ExpressionStatement> node;
        result = walkAstParent<Error>(
          expressionStatement.expression,
          <WalkAstCallback<Error>> callback,
          expressionStatement,
        );
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.DeferStatement:
      {
        const deferStatement = <ast.DeferStatement> node;
        result = walkAstParent<Error>(deferStatement.body, <WalkAstCallback<Error>> callback, deferStatement);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.IfStatement:
      {
        const ifStatement = <ast.IfStatement> node;
        result = walkAstParent<Error>(ifStatement.condition, <WalkAstCallback<Error>> callback, ifStatement);
        if (isError(result)) return result;
        result = walkAstParent<Error>(ifStatement.then, <WalkAstCallback<Error>> callback, ifStatement);
        if (isError(result)) return result;
        if (ifStatement.else) {
          result = walkAstParent<Error>(ifStatement.else, <WalkAstCallback<Error>> callback, ifStatement);
          if (isError(result)) return result;
        }
      }
      break;
    case ast.SyntaxKind.WhileStatement:
      {
        const whileStatement = <ast.WhileStatement> node;
        result = walkAstParent<Error>(whileStatement.condition, <WalkAstCallback<Error>> callback, whileStatement);
        if (isError(result)) return result;
        result = walkAstParent<Error>(whileStatement.body, <WalkAstCallback<Error>> callback, whileStatement);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.ReturnStatement:
      {
        const returnStatement = <ast.ReturnStatement> node;
        result = walkAstParent<Error>(returnStatement.expression, <WalkAstCallback<Error>> callback, returnStatement);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.StatementBlock:
      {
        const statementBlock = <ast.StatementBlock> node;
        result = walkAstArrayParent<Error>(
          statementBlock.statements,
          <WalkAstCallback<Error>> callback,
          statementBlock,
        );
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.LogicalExpression:
      {
        const logicalExpression = <ast.LogicalExpression> node;
        result = walkAstParent<Error>(logicalExpression.lhs, <WalkAstCallback<Error>> callback, logicalExpression);
        if (isError(result)) return result;
        result = walkAstParent<Error>(logicalExpression.rhs, <WalkAstCallback<Error>> callback, logicalExpression);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.AssignmentExpression:
      {
        const assignmentExpression = <ast.AssignmentExpression> node;
        result = walkAstParent<Error>(
          assignmentExpression.name,
          <WalkAstCallback<Error>> callback,
          assignmentExpression,
        );
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.EqualityExpression:
      {
        const equalityExpression = <ast.EqualityExpression> node;
        result = walkAstParent<Error>(equalityExpression.lhs, <WalkAstCallback<Error>> callback, equalityExpression);
        if (isError(result)) return result;
        result = walkAstParent<Error>(equalityExpression.rhs, <WalkAstCallback<Error>> callback, equalityExpression);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.ComparisonExpression:
      {
        const comparisonExpression = <ast.ComparisonExpression> node;
        result = walkAstParent<Error>(
          comparisonExpression.lhs,
          <WalkAstCallback<Error>> callback,
          comparisonExpression,
        );
        if (isError(result)) return result;
        result = walkAstParent<Error>(
          comparisonExpression.rhs,
          <WalkAstCallback<Error>> callback,
          comparisonExpression,
        );
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.AdditiveExpression:
      {
        const additiveExpression = <ast.AdditiveExpression> node;
        result = walkAstParent<Error>(additiveExpression.lhs, <WalkAstCallback<Error>> callback, additiveExpression);
        if (isError(result)) return result;
        result = walkAstParent<Error>(additiveExpression.rhs, <WalkAstCallback<Error>> callback, additiveExpression);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.MultiplicativeExpression:
      {
        const multiplicativeExpression = <ast.MultiplicativeExpression> node;
        result = walkAstParent<Error>(
          multiplicativeExpression.lhs,
          <WalkAstCallback<Error>> callback,
          multiplicativeExpression,
        );
        if (isError(result)) return result;
        result = walkAstParent<Error>(
          multiplicativeExpression.rhs,
          <WalkAstCallback<Error>> callback,
          multiplicativeExpression,
        );
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.UnaryExpression:
      {
        const unaryExpression = <ast.UnaryExpression> node;
        result = walkAstParent<Error>(unaryExpression.expression, <WalkAstCallback<Error>> callback, unaryExpression);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.ParenthesizedExpression:
      {
        const parenthesizedExpression = <ast.ParenthesizedExpression> node;
        result = walkAstParent<Error>(
          parenthesizedExpression.expression,
          <WalkAstCallback<Error>> callback,
          parenthesizedExpression,
        );
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.CallExpression:
      {
        const callExpression = <ast.CallExpression> node;
        result = walkAstParent<Error>(callExpression.expression, <WalkAstCallback<Error>> callback, callExpression);
        if (isError(result)) return result;
        result = walkAstArrayParent<Error>(callExpression.arguments, <WalkAstCallback<Error>> callback, callExpression);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.ElementAccessExpression:
      {
        const elementAccessExpression = <ast.ElementAccessExpression> node;
        result = walkAstParent<Error>(
          elementAccessExpression.expression,
          <WalkAstCallback<Error>> callback,
          elementAccessExpression,
        );
        if (isError(result)) return result;
        result = walkAstParent<Error>(
          elementAccessExpression.argumentExpression,
          <WalkAstCallback<Error>> callback,
          elementAccessExpression,
        );
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.PropertyAccessExpression:
      {
        const propertyAccessExpression = <ast.PropertyAccessExpression> node;
        result = walkAstParent<Error>(
          propertyAccessExpression.expression,
          <WalkAstCallback<Error>> callback,
          propertyAccessExpression,
        );
        if (isError(result)) return result;
        result = walkAstParent<Error>(
          propertyAccessExpression.name,
          <WalkAstCallback<Error>> callback,
          propertyAccessExpression,
        );
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.ArrayType:
      {
        const arrayType = <ast.ArrayType> node;
        result = walkAstParent<Error>(arrayType.elementType, <WalkAstCallback<Error>> callback, arrayType);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.PointerType:
      {
        const pointerType = <ast.PointerType> node;
        result = walkAstParent<Error>(pointerType.elementType, <WalkAstCallback<Error>> callback, pointerType);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.TypeReference:
      {
        const typeReference = <ast.TypeReference> node;
        result = walkAstParent<Error>(typeReference.typeName, <WalkAstCallback<Error>> callback, typeReference);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.QualifiedName:
      {
        const qualifiedName = <ast.QualifiedName> node;
        result = walkAstParent<Error>(qualifiedName.left, <WalkAstCallback<Error>> callback, qualifiedName);
        if (isError(result)) return result;
        result = walkAstParent<Error>(qualifiedName.right, <WalkAstCallback<Error>> callback, qualifiedName);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.ArrayLiteral:
      {
        const arrayLiteral = <ast.ArrayLiteral> node;
        result = walkAstArrayParent<Error>(arrayLiteral.elements, <WalkAstCallback<Error>> callback, arrayLiteral);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.StructLiteral:
      {
        const structLiteral = <ast.StructLiteral> node;
        result = walkAstArrayParent<Error>(structLiteral.elements, <WalkAstCallback<Error>> callback, structLiteral);
        if (isError(result)) return result;
      }
      break;
    case ast.SyntaxKind.StructLiteralElement:
      {
        const structLiteralElement = <ast.StructLiteralElement> node;
        if (structLiteralElement.name) {
          result = walkAstParent<Error>(
            structLiteralElement.name,
            <WalkAstCallback<Error>> callback,
            structLiteralElement,
          );
          if (isError(result)) return result;
        }
        result = walkAstParent<Error>(
          structLiteralElement.expression,
          <WalkAstCallback<Error>> callback,
          structLiteralElement,
        );
        if (isError(result)) return result;
      }
      break;
  }
  return success();
}
